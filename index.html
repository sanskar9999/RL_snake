<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Snake Competition - 5 Snakes (RL)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #111;
            font-family: Arial, sans-serif;
            color: white;
        }
        canvas {
            border: 1px solid #333;
            background-color: black;
        }
        #controlsContainer {
            position: relative;
        }
        #infoButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 1001;
        }
        #paramsPanel {
            display: none;
            position: fixed;
            bottom: 70px;
            right: 20px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 1000;
            color: white;
            max-height: 70vh;
            overflow-y: auto;
        }
        #paramsPanel h3 {
            margin-top: 0;
            color: #00aaff;
        }
        #paramsPanel label {
            display: block;
            margin-top: 10px;
            font-size: 0.9em;
        }
        #paramsPanel input[type="number"] {
            width: 80px;
            padding: 5px;
            margin-top: 3px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
        }
        #paramsPanel .snake-params {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #555;
        }
        #paramsPanel .snake-params:last-child {
            border-bottom: none;
        }
        #applyParamsButton, #closeParamsButton {
            margin-top: 15px;
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        #applyParamsButton:hover, #closeParamsButton:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div id="controlsContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <button id="infoButton">?</button>

    <div id="paramsPanel">
        <h3>AI Parameters (Non-RL)</h3>
        <div id="snakeParamsForms">
            <!-- Forms will be generated by JS -->
        </div>
        <button id="applyParamsButton">Apply</button>
        <button id="closeParamsButton">Close</button>
    </div>

    <script>
        // --- Constants ---
        const SCREEN_WIDTH = 1280;
        const SCREEN_HEIGHT = 720;
        const GRID_SIZE = 10; // Make sure this matches Python's GRID_WIDTH/HEIGHT if they were used for normalization constants
        const GRID_WIDTH = SCREEN_WIDTH / GRID_SIZE;   // e.g. 128
        const GRID_HEIGHT = SCREEN_HEIGHT / GRID_SIZE; // e.g. 72

        const BLACK = 'rgb(0, 0, 0)';
        const WHITE = 'rgb(255, 255, 255)';
        const RED = 'rgb(255, 0, 0)';
        const GRID_COLOR = 'rgb(10, 10, 10)';
        const SNAKE1_COLOR = 'rgb(0, 255, 0)';    // Green (O)
        const SNAKE2_COLOR = 'rgb(0, 0, 255)';    // Blue (O1)
        const SNAKE3_COLOR = 'rgb(255, 255, 0)';  // Yellow (O2)
        const SNAKE4_COLOR = 'rgb(255, 0, 255)';  // Magenta (O3)
        const SNAKE_RL_COLOR = 'rgb(255, 165, 0)'; // Orange (RL)


        const UP = { x: 0, y: -1 };
        const DOWN = { x: 0, y: 1 };
        const LEFT = { x: -1, y: 0 };
        const RIGHT = { x: 1, y: 0 };
        const DIRECTIONS = [UP, DOWN, LEFT, RIGHT];


        const RESPAWN_TIME = 100; // In frames
        const TARGET_FOOD_COUNT = 10; // Increased for 5 snakes

        // Global best parameters (can be updated by the game)
        let global_best_o1 = { score: 78, food_weight: 0.84, safety_weight: 0.47, look_ahead: 3, aggression: 0.50 };
        let global_best_o2 = { score: 6054, food_weight: 0.10, safety_weight: 4.80, look_ahead: 10, aggression: 1.35 };
        let global_best_o3 = { score: 3946, food_weight: 0.10, safety_weight: 4.89, look_ahead: 10, aggression: 1.58 };

        let best_snake_overall = { snake: 'SnakeO2', score: 6054, food_weight: 0.10, safety_weight: 4.80, look_ahead: 10, aggression: 1.35 };

        // --- RL Snake Constants (must match Python training environment) ---
        const STATE_SIZE_RL = 32;
        const MAX_SNAKE_LENGTH_RL = 50; // From Python's MAX_SNAKE_LENGTH
        // From Python: RAYCAST_DISTANCE = max(GRID_WIDTH, GRID_HEIGHT) * 2
        // Use JS GRID_WIDTH/HEIGHT which are cells, Python used pixel grid size for this.
        // If Python's GRID_WIDTH was 20, then RAYCAST_DISTANCE was max(20,20)*2 = 40.
        // Let's assume Python's GRID_WIDTH/HEIGHT for raycast was 20.
        const PYTHON_GRID_DIM_FOR_RAYCAST = 20; // The grid dimension used in Python for RAYCAST_DISTANCE calc
        const RAYCAST_DISTANCE_RL = Math.max(PYTHON_GRID_DIM_FOR_RAYCAST, PYTHON_GRID_DIM_FOR_RAYCAST) * 2;


        // --- Utility Functions ---
        function randomUniform(min, max) { return Math.random() * (max - min) + min; }
        function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function randomChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
        function directionKey(dir) { return `${dir.x},${dir.y}`; }
        function hasattr(obj, prop) { return typeof obj[prop] !== 'undefined'; }


        // --- Classes ---
        class SnakeO {
            constructor(snake_id, start_position, start_direction, color) {
                this.snake_id = snake_id;
                this.name = "O";
                this.positions = [start_position];
                this.length = 5;
                this.direction = start_direction;
                this.score = 0;
                this.color = color;
                this.alive = true;
                this.move_cooldown = 0;
                this.respawn_counter = 0;
            }
            get_head_position() { return this.positions[0]; }

            update(other_snakes_positions) {
                if (!this.alive) {
                    if (this.respawn_counter > 0) {
                        this.respawn_counter -= 1;
                        if (this.respawn_counter === 0) this.reset();
                    }
                    return [];
                }
                if (this.move_cooldown > 0) this.move_cooldown -= 1;

                const head = this.get_head_position();
                const new_position = {
                    x: (head.x + this.direction.x + GRID_WIDTH) % GRID_WIDTH,
                    y: (head.y + this.direction.y + GRID_HEIGHT) % GRID_HEIGHT
                };
                let collided = false;
                // Check self collision
                for (let i = 1; i < this.positions.length; i++) {
                    if (this.positions[i].x === new_position.x && this.positions[i].y === new_position.y) {
                        collided = true; this.last_collision_type = 'self'; break;
                    }
                }
                // Check collision with other snakes
                if (!collided) {
                    for (const pos of other_snakes_positions) {
                        if (pos.x === new_position.x && pos.y === new_position.y) {
                            collided = true; this.last_collision_type = 'other'; break;
                        }
                    }
                }
                if (collided) {
                    const food_count = Math.max(Math.floor(this.length / 2), 1);
                    let food_to_spawn = [];
                    for (let i = 0; i < food_count; i++) {
                        if (i < this.positions.length) food_to_spawn.push({...this.positions[i]});
                    }
                    this.alive = false; this.respawn_counter = RESPAWN_TIME; this.score -= 10;
                    return food_to_spawn;
                }
                this.positions.unshift(new_position);
                if (this.positions.length > this.length) this.positions.pop();
                if (this.alive && hasattr(this, 'hunger')) this.hunger++;
                return [];
            }
            reset() {
                // Default start positions - ensure they are spread out
                if (this.snake_id === 0) this.positions = [{ x: Math.floor(1 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }]; // O
                else if (this.snake_id === 1) this.positions = [{ x: Math.floor(2 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }]; // O1
                else if (this.snake_id === 2) this.positions = [{ x: Math.floor(3 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }]; // O2
                else if (this.snake_id === 3) this.positions = [{ x: Math.floor(4 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }]; // O3
                else if (this.snake_id === 4) this.positions = [{ x: Math.floor(5 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }]; // RL

                this.direction = (this.snake_id % 2 === 0) ? RIGHT : LEFT; // Alternate starting directions
                this.length = (this.name === "RL" || this.name === "O1" || this.name === "O2" || this.name === "O3") ? 3 : 5;
                this.alive = true;
                if (hasattr(this, 'hunger')) this.hunger = 0;
                this.last_collision_type = null;
            }
            ai_move(food_positions, other_snakes_positions, other_snakes_heads) {
                if (!this.alive || this.move_cooldown > 0) return;
                // Basic SnakeO AI (as before)
                const head = this.get_head_position();
                let nearest_food = null; let min_dist = Infinity;
                if (food_positions.length > 0) {
                    food_positions.forEach(f => {
                        const dist = Math.abs(head.x - f.x) + Math.abs(head.y - f.y);
                        if (dist < min_dist) { min_dist = dist; nearest_food = f; }
                    });
                }
                let possible_directions = [];
                if (nearest_food) {
                    let dx = nearest_food.x - head.x; let dy = nearest_food.y - head.y;
                    if (Math.abs(dx) > GRID_WIDTH / 2) dx = dx > 0 ? dx - GRID_WIDTH : dx + GRID_WIDTH;
                    if (Math.abs(dy) > GRID_HEIGHT / 2) dy = dy > 0 ? dy - GRID_HEIGHT : dy + GRID_HEIGHT;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 0 && this.direction !== LEFT) possible_directions.push(RIGHT);
                        else if (dx < 0 && this.direction !== RIGHT) possible_directions.push(LEFT);
                        if (dy > 0 && this.direction !== UP) possible_directions.push(DOWN);
                        else if (dy < 0 && this.direction !== DOWN) possible_directions.push(UP);
                    } else {
                        if (dy > 0 && this.direction !== UP) possible_directions.push(DOWN);
                        else if (dy < 0 && this.direction !== DOWN) possible_directions.push(UP);
                        if (dx > 0 && this.direction !== LEFT) possible_directions.push(RIGHT);
                        else if (dx < 0 && this.direction !== RIGHT) possible_directions.push(LEFT);
                    }
                } else {
                     DIRECTIONS.forEach(d => { if (d.x !== -this.direction.x || d.y !== -this.direction.y) possible_directions.push(d); });
                }
                if (possible_directions.length === 0) DIRECTIONS.forEach(d => possible_directions.push(d));

                const safe_directions = [];
                for (const direction of possible_directions) {
                    const new_pos = { x: (head.x + direction.x + GRID_WIDTH) % GRID_WIDTH, y: (head.y + direction.y + GRID_HEIGHT) % GRID_HEIGHT };
                    let is_safe = true;
                    for (let i = 0; i < this.positions.length; i++) { if (this.positions[i].x === new_pos.x && this.positions[i].y === new_pos.y) { is_safe = false; break; } }
                    if (is_safe) { for (const osp of other_snakes_positions) { if (osp.x === new_pos.x && osp.y === new_pos.y) { is_safe = false; break; } } }
                    if (is_safe) safe_directions.push(direction);
                }

                if (safe_directions.length > 0) this.direction = safe_directions[0];
                else if (possible_directions.length > 0) this.direction = possible_directions[0];
                else {
                    const nonReversing = DIRECTIONS.filter(d => d.x !== -this.direction.x || d.y !== -this.direction.y);
                    if (nonReversing.length > 0) this.direction = randomChoice(nonReversing); else this.direction = randomChoice(DIRECTIONS);
                }
                this.move_cooldown = 1;
            }
            render(ctx) { /* ... (same as before) ... */
                if (!this.alive) return;
                this.positions.forEach((pos, index) => {
                    let r = parseInt(this.color.substring(4, this.color.indexOf(',')));
                    let g = parseInt(this.color.substring(this.color.indexOf(',') + 1, this.color.lastIndexOf(',')));
                    let b = parseInt(this.color.substring(this.color.lastIndexOf(',') + 1, this.color.indexOf(')')));
                    const current_color = (index === 0) ? `rgb(${Math.max(0,r-30)}, ${Math.max(0,g-30)}, ${Math.max(0,b-30)})` : this.color;
                    ctx.fillStyle = current_color;
                    ctx.fillRect(pos.x * GRID_SIZE, pos.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    ctx.strokeStyle = BLACK;
                    ctx.strokeRect(pos.x * GRID_SIZE, pos.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                });
            }
        }

        class LearningSnake extends SnakeO {
            constructor(snake_id, start_position, start_direction, color, global_best_params, name) {
                super(snake_id, start_position, start_direction, color);
                this.name = name; this.length = 3;
                this.food_weight = global_best_params.food_weight; this.safety_weight = global_best_params.safety_weight;
                this.look_ahead = global_best_params.look_ahead; this.aggression = global_best_params.aggression;
                this.best_score_personal = global_best_params.score;
                this.best_food_weight = this.food_weight; this.best_safety_weight = this.safety_weight;
                this.best_look_ahead = this.look_ahead; this.best_aggression = this.aggression;
                this.mutation_rate = 0.1; this.aggressive_mutation = false;
            }
            reset(global_best_ref) {
                super.reset(); // Calls SnakeO.reset for position, length, alive status
                if (this.score > this.best_score_personal) {
                    this.best_score_personal = this.score;
                    this.best_food_weight = this.food_weight; this.best_safety_weight = this.safety_weight;
                    this.best_look_ahead = this.look_ahead; this.best_aggression = this.aggression;
                    this.aggressive_mutation = false;
                    if (this.score > global_best_ref.score) {
                        global_best_ref.score = this.score; global_best_ref.food_weight = this.food_weight;
                        global_best_ref.safety_weight = this.safety_weight; global_best_ref.look_ahead = this.look_ahead;
                        global_best_ref.aggression = this.aggression;
                    }
                    if (this.score > best_snake_overall.score) {
                        best_snake_overall.snake = `Snake${this.name}`; best_snake_overall.score = this.score;
                        best_snake_overall.food_weight = this.food_weight; best_snake_overall.safety_weight = this.safety_weight;
                        best_snake_overall.look_ahead = this.look_ahead; best_snake_overall.aggression = this.aggression;
                    }
                } else {
                    this.food_weight = this.best_food_weight; this.safety_weight = this.best_safety_weight;
                    this.look_ahead = this.best_look_ahead; this.aggression = this.best_aggression;
                    this.aggressive_mutation = true;
                }
                this.mutate_parameters();
                // O2/O3 specific adjustments after mutation
                if (this.name === "O2" || this.name === "O3") {
                    if (this.last_move_safety === 0) { this.safety_weight += this.mutation_rate; this.food_weight -= this.mutation_rate; }
                    if (this.last_collision_type === 'other') this.look_ahead = Math.min(this.look_ahead + 1, 10);
                    else if (this.last_collision_type === 'self') this.safety_weight += this.mutation_rate;
                    this.food_weight = Math.max(0.1, Math.min(5.0, this.food_weight));
                    this.safety_weight = Math.max(0.1, Math.min(5.0, this.safety_weight));
                }
            }
            mutate_parameters() { /* ... (same as before) ... */
                const rate = this.mutation_rate * (this.aggressive_mutation ? 2 : 1);
                this.food_weight = Math.max(0.1, Math.min(5.0, this.food_weight + randomUniform(-rate, rate)));
                this.safety_weight = Math.max(0.1, Math.min(5.0, this.safety_weight + randomUniform(-rate, rate)));
                this.aggression = Math.max(0.0, Math.min(2.0, this.aggression + randomUniform(-rate, rate)));
                this.look_ahead = Math.max(1, Math.min(10, this.look_ahead + randomChoice([-1, 0, 1])));
            }
            ai_move(food_positions, other_snakes_positions, other_snakes_heads) { /* ... (same as before, with hasattr checks) ... */
                if (!this.alive || this.move_cooldown > 0) return;
                const head = this.get_head_position(); const scores = {};
                DIRECTIONS.forEach(direction => {
                    if (direction.x === -this.direction.x && direction.y === -this.direction.y) return;
                    let is_safe_move = true; let future_pos = { ...head };
                    for (let step = 0; step < this.look_ahead; step++) {
                        future_pos.x = (future_pos.x + direction.x + GRID_WIDTH) % GRID_WIDTH;
                        future_pos.y = (future_pos.y + direction.y + GRID_HEIGHT) % GRID_HEIGHT;
                        for (let i = 0; i < this.positions.length; i++) { if (this.positions[i].x === future_pos.x && this.positions[i].y === future_pos.y) { is_safe_move = false; break; } }
                        if (!is_safe_move) break;
                        if (this.name === "O3" && step === 0) { for (const osp of other_snakes_positions) { if (osp.x === future_pos.x && osp.y === future_pos.y) { is_safe_move = false; break; } } }
                        else if (this.name !== "O3") { for (const osp of other_snakes_positions) { if (osp.x === future_pos.x && osp.y === future_pos.y) { is_safe_move = false; break; } } }
                        if (!is_safe_move) break;
                    }
                    const safety_score = is_safe_move ? 1 : 0;
                    const new_head = { x: (head.x + direction.x + GRID_WIDTH) % GRID_WIDTH, y: (head.y + direction.y + GRID_HEIGHT) % GRID_HEIGHT };
                    let food_benefit = 0;
                    if (food_positions.length > 0) {
                        const current_food_dist = Math.min(...food_positions.map(f => Math.abs(head.x - f.x) + Math.abs(head.y - f.y)));
                        const new_food_dist = Math.min(...food_positions.map(f => Math.abs(new_head.x - f.x) + Math.abs(new_head.y - f.y)));
                        food_benefit = current_food_dist - new_food_dist;
                    }
                    let aggression_score = 0;
                    if (other_snakes_heads.length > 0) {
                        const current_enemy_dist = Math.min(...other_snakes_heads.map(h => Math.abs(head.x - h.x) + Math.abs(head.y - h.y)));
                        const new_enemy_dist = Math.min(...other_snakes_heads.map(h => Math.abs(new_head.x - h.x) + Math.abs(new_head.y - h.y)));
                        aggression_score = (current_enemy_dist - new_enemy_dist) * this.aggression;
                    }
                    let hunger_modifier = 1; if (this.name === "O3" && hasattr(this, 'hunger')) hunger_modifier = 1 + (this.hunger * 0.005);
                    scores[directionKey(direction)] = { total: (food_benefit * this.food_weight * hunger_modifier) + (safety_score * this.safety_weight) + aggression_score, safety: safety_score, dir: direction };
                });
                const valid_moves = Object.values(scores);
                if (valid_moves.length > 0) {
                    let best_move_data;
                    if (this.name === "O3") { const max_score_val = Math.max(...valid_moves.map(m => m.total)); const best_options = valid_moves.filter(m => m.total === max_score_val); best_move_data = randomChoice(best_options); }
                    else { best_move_data = valid_moves.reduce((best, current) => (current.total > best.total ? current : best)); }
                    this.direction = best_move_data.dir; if (hasattr(this, 'last_move_safety')) this.last_move_safety = best_move_data.safety;
                } else {
                    const forward = this.direction; const new_head_forward = { x: (head.x + forward.x + GRID_WIDTH) % GRID_WIDTH, y: (head.y + forward.y + GRID_HEIGHT) % GRID_HEIGHT };
                    let can_move_forward = true;
                    for (let i = 0; i < this.positions.length; i++) { if (this.positions[i].x === new_head_forward.x && this.positions[i].y === new_head_forward.y) { can_move_forward = false; break; } }
                    if (can_move_forward) { for (const osp of other_snakes_positions) { if (osp.x === new_head_forward.x && osp.y === new_head_forward.y) { can_move_forward = false; break; } } }
                    if (!can_move_forward) { const nonReversing = DIRECTIONS.filter(d => d.x !== -this.direction.x || d.y !== -this.direction.y); if (nonReversing.length > 0) this.direction = randomChoice(nonReversing); else this.direction = randomChoice(DIRECTIONS); }
                }
                this.move_cooldown = 1;
            }
        }
        class SnakeO1 extends LearningSnake { constructor(id,pos,dir,col) { super(id,pos,dir,col,global_best_o1,"O1"); } reset() { super.reset(global_best_o1); } }
        class SnakeO2 extends LearningSnake { constructor(id,pos,dir,col) { super(id,pos,dir,col,global_best_o2,"O2"); this.last_move_safety=1; this.last_collision_type=null;} reset() { super.reset(global_best_o2); } }
        class SnakeO3 extends LearningSnake { constructor(id,pos,dir,col) { super(id,pos,dir,col,global_best_o3,"O3"); this.last_move_safety=1; this.last_collision_type=null; this.hunger=0;} reset() { super.reset(global_best_o3); } }

        // --- RL Snake Class ---
        class SnakeRL extends SnakeO {
            constructor(snake_id, start_position, start_direction, color, modelPath = './model_rl_snake_tfjs/model.json') {
                super(snake_id, start_position, start_direction, color);
                this.name = "RL";
                this.length = 3; // RL snakes start smaller
                this.model = null;
                this.modelPath = modelPath;
                this.isModelLoading = true;
                this._loadModel();

                // JS Mappings for RL actions/directions (consistent with Python training)
                // Python ACTIONS: [0, 1, 2, 3]  # Up, Right, Down, Left
                // Python DIRECTIONS: [(0, -1), (1, 0), (0, 1), (-1, 0)]
                this.PY_ACTIONS_TO_JS_DIR = [
                    {x:0, y:-1}, // 0: Up
                    {x:1, y:0},  // 1: Right
                    {x:0, y:1},  // 2: Down
                    {x:-1, y:0}  // 3: Left
                ];
                this.JS_DIR_TO_PY_ACTION = {
                    "0,-1": 0, "1,0": 1, "0,1": 2, "-1,0": 3
                };
                this.OPPOSITE_PY_ACTIONS = {0: 2, 1: 3, 2: 0, 3: 1}; // Opposite of Up is Down, etc.

                // Raycast directions (N, NE, E, SE, S, SW, W, NW)
                this.RAY_DIRECTIONS_RELATIVE_JS = [
                    {x:0,y:-1}, {x:1,y:-1}, {x:1,y:0}, {x:1,y:1},
                    {x:0,y:1}, {-1,y:1}, {-1,y:0}, {-1,y:-1}
                ];
            }

            async _loadModel() {
                try {
                    console.log(`Loading RL model from ${this.modelPath}...`);
                    this.model = await tf.loadLayersModel(this.modelPath);
                    console.log("RL Model loaded successfully.");
                    const dummyState = tf.zeros([1, STATE_SIZE_RL]);
                    this.model.predict(dummyState).dispose(); // Warm up
                    dummyState.dispose();
                    console.log("RL Model warmed up.");
                } catch (error) {
                    console.error("Error loading RL model:", error);
                    alert(`Failed to load RL model. Check console and ensure model files are in ${this.modelPath.substring(0, this.modelPath.lastIndexOf('/'))}`);
                } finally {
                    this.isModelLoading = false;
                }
            }

            _normalize_pos_js(pos, gridW, gridH) {
                return [pos.x / (gridW - 1 + 1e-9), pos.y / (gridH - 1 + 1e-9)];
            }
            _normalize_length_js(length) {
                return length / (MAX_SNAKE_LENGTH_RL + 1e-9);
            }
            _normalize_distance_js(dist) {
                return dist / (RAYCAST_DISTANCE_RL + 1e-9);
            }

            _raycast_js(start_pos, direction_vec, obstacles_coords_set) {
                let current_x = start_pos.x;
                let current_y = start_pos.y;
                const dx = direction_vec.x;
                const dy = direction_vec.y;
                for (let dist = 1; dist <= RAYCAST_DISTANCE_RL; dist++) {
                    current_x = (current_x + dx + GRID_WIDTH) % GRID_WIDTH;
                    current_y = (current_y + dy + GRID_HEIGHT) % GRID_HEIGHT;
                    if (obstacles_coords_set.has(`${current_x},${current_y}`)) {
                        return this._normalize_distance_js(dist);
                    }
                }
                return this._normalize_distance_js(RAYCAST_DISTANCE_RL);
            }

            _get_relative_food_pos_js(head_pos, food_pos) {
                let dx = food_pos.x - head_pos.x;
                let dy = food_pos.y - head_pos.y;

                if (dx > GRID_WIDTH / 2) dx -= GRID_WIDTH;
                else if (dx < -GRID_WIDTH / 2) dx += GRID_WIDTH;
                if (dy > GRID_HEIGHT / 2) dy -= GRID_HEIGHT;
                else if (dy < -GRID_HEIGHT / 2) dy += GRID_HEIGHT;

                return [dx / (GRID_WIDTH / 2 + 1e-9), dy / (GRID_HEIGHT / 2 + 1e-9)];
            }

            _get_state_rl(allSnakes, allFood) {
                const state = new Float32Array(STATE_SIZE_RL);
                let offset = 0;

                const selfSnake = this;
                // Determine opponent: For simplicity, pick the first *other* alive snake.
                // If none, use a dummy dead opponent.
                let opponentSnake = null;
                for (const s of allSnakes) {
                    if (s !== selfSnake && s.alive) {
                        opponentSnake = s;
                        break;
                    }
                }
                 // If no alive opponent, pick the first other snake (even if dead) as a placeholder
                if (!opponentSnake) {
                    for (const s of allSnakes) {
                        if (s !== selfSnake) {
                            opponentSnake = s; // This might be a dead snake
                            break;
                        }
                    }
                }
                // If still no opponent (e.g. RL snake is the only one, highly unlikely), create a dummy
                if (!opponentSnake && allSnakes.length > 1) { // Should not happen if there's more than 1 snake
                     opponentSnake = allSnakes.find(s => s !== selfSnake); // Find any other snake
                } else if (!opponentSnake) { // Only RL snake exists
                    opponentSnake = { // Dummy opponent
                        positions: [{x:-1,y:-1}], direction: {x:1,y:0}, length: 0, alive: false,
                        get_head_position: function() { return this.positions[0]; }
                    };
                }


                // --- Self Features (15 dims) ---
                const selfHeadPos = selfSnake.get_head_position();
                const normSelfHeadPos = this._normalize_pos_js(selfHeadPos, GRID_WIDTH, GRID_HEIGHT);
                state[offset++] = normSelfHeadPos[0];
                state[offset++] = normSelfHeadPos[1];

                const selfDirKey = `${selfSnake.direction.x},${selfSnake.direction.y}`;
                const selfDirAction = this.JS_DIR_TO_PY_ACTION[selfDirKey] !== undefined ? this.JS_DIR_TO_PY_ACTION[selfDirKey] : 0; // Default to UP
                for (let i = 0; i < 4; i++) state[offset++] = (i === selfDirAction) ? 1.0 : 0.0;

                state[offset++] = this._normalize_length_js(selfSnake.length);

                const selfBodyObstacles = new Set(selfSnake.positions.slice(1).map(p => `${p.x},${p.y}`));
                for (const rayDir of this.RAY_DIRECTIONS_RELATIVE_JS) {
                    state[offset++] = this._raycast_js(selfHeadPos, rayDir, selfBodyObstacles);
                }

                // --- Opponent Features (15 dims) ---
                const oppHeadPos = opponentSnake.alive ? opponentSnake.get_head_position() : {x:-100, y:-100}; // Off-grid if dead
                const normOppHeadPos = this._normalize_pos_js(oppHeadPos, GRID_WIDTH, GRID_HEIGHT);
                state[offset++] = normOppHeadPos[0];
                state[offset++] = normOppHeadPos[1];

                const oppDirKey = `${opponentSnake.direction.x},${opponentSnake.direction.y}`;
                const oppDirAction = opponentSnake.alive && this.JS_DIR_TO_PY_ACTION[oppDirKey] !== undefined ? this.JS_DIR_TO_PY_ACTION[oppDirKey] : 0;
                for (let i = 0; i < 4; i++) state[offset++] = (i === oppDirAction) ? 1.0 : 0.0;

                state[offset++] = opponentSnake.alive ? this._normalize_length_js(opponentSnake.length) : 0.0;

                const oppBodyObstacles = opponentSnake.alive ? new Set(opponentSnake.positions.slice(1).map(p => `${p.x},${p.y}`)) : new Set();
                for (const rayDir of this.RAY_DIRECTIONS_RELATIVE_JS) {
                    state[offset++] = this._raycast_js(selfHeadPos, rayDir, oppBodyObstacles); // Raycast from self's perspective
                }

                // --- Food Features (2 dims) ---
                if (allFood.length > 0) {
                    // Find closest food for relative position, as Python version likely did implicitly or explicitly
                    let closestFoodPos = allFood[0].position;
                    let minDistSq = Infinity;
                    for(const foodItem of allFood) {
                        const dx = foodItem.position.x - selfHeadPos.x;
                        const dy = foodItem.position.y - selfHeadPos.y;
                        const distSq = dx*dx + dy*dy; // Simple distance for finding closest
                        if (distSq < minDistSq) {
                            minDistSq = distSq;
                            closestFoodPos = foodItem.position;
                        }
                    }
                    const relativeFood = this._get_relative_food_pos_js(selfHeadPos, closestFoodPos);
                    state[offset++] = relativeFood[0];
                    state[offset++] = relativeFood[1];
                } else {
                    state[offset++] = 0.0;
                    state[offset++] = 0.0;
                }
                if (offset !== STATE_SIZE_RL) console.error(`State size mismatch! Expected ${STATE_SIZE_RL}, got ${offset}`);
                return state;
            }

            ai_move(food_positions_js, other_snakes_positions_js, other_snakes_heads_js) {
                if (!this.alive || this.move_cooldown > 0 || !this.model || this.isModelLoading) {
                    if (this.isModelLoading && !this.model) { /* console.log("RL model not ready, RL snake waits."); */ }
                    // Fallback: if model not ready, do a simple forward or random non-reverse
                    if (this.alive && this.move_cooldown === 0 && (!this.model || this.isModelLoading)) {
                        const valid_directions = DIRECTIONS.filter(d => !(d.x === -this.direction.x && d.y === -this.direction.y));
                        if (valid_directions.length > 0) this.direction = randomChoice(valid_directions);
                        else this.direction = randomChoice(DIRECTIONS);
                         this.move_cooldown = 1;
                    }
                    return;
                }

                // `food_positions_js` is an array of {x,y} food objects.
                // We need all snake objects for _get_state_rl. Assuming `window.game.snakes` is available.
                const allSnakes = window.game.snakes;
                const allFoodObjects = window.game.foods; // This contains full food objects with .position

                const stateArray = this._get_state_rl(allSnakes, allFoodObjects);
                if (!stateArray) { console.error("Failed to get state for RL snake."); return; }

                let py_action_idx;
                tf.tidy(() => {
                    const stateTensor = tf.tensor2d([stateArray], [1, STATE_SIZE_RL]);
                    const q_values_tensor = this.model.predict(stateTensor);
                    const q_values_data = q_values_tensor.dataSync();

                    const current_py_action = this.JS_DIR_TO_PY_ACTION[`${this.direction.x},${this.direction.y}`];
                    const invalid_py_action = this.OPPOSITE_PY_ACTIONS[current_py_action];

                    let best_q = -Infinity;
                    py_action_idx = -1;

                    for (let i = 0; i < q_values_data.length; i++) {
                        if (i === invalid_py_action) continue; // Skip invalid action
                        if (q_values_data[i] > best_q) {
                            best_q = q_values_data[i];
                            py_action_idx = i;
                        }
                    }
                     // If all valid actions had -Infinity or no valid action found, pick any non-opposite
                    if (py_action_idx === -1) {
                        const possible_actions = [0,1,2,3].filter(a => a !== invalid_py_action);
                        py_action_idx = randomChoice(possible_actions);
                        if(py_action_idx === undefined && possible_actions.length === 0) py_action_idx = 0; // Absolute fallback
                         console.warn("RL Snake: No preferred valid action, choosing random non-opposite.");
                    }
                });

                if (py_action_idx !== undefined && py_action_idx !== -1) {
                    this.direction = this.PY_ACTIONS_TO_JS_DIR[py_action_idx];
                } else {
                    console.warn("RL snake action selection failed, choosing random valid JS direction.");
                    const valid_js_directions = DIRECTIONS.filter(d => !(d.x === -this.direction.x && d.y === -this.direction.y));
                    if (valid_js_directions.length > 0) this.direction = randomChoice(valid_js_directions);
                }
                this.move_cooldown = 1;
            }
            // RL snake does not mutate parameters, so its reset is simpler
            reset() {
                super.reset(); // Calls SnakeO.reset for position, length, alive status
                // No parameter mutation or best score tracking needed here as model is fixed.
            }
        }


        class Food { /* ... (same as before) ... */
            constructor(position = null) { this.color = RED; this.position = position ? position : this.randomize_position(); }
            randomize_position() { return { x: randomInt(0, GRID_WIDTH - 1), y: randomInt(0, GRID_HEIGHT - 1) }; }
            render(ctx) { ctx.fillStyle = this.color; ctx.fillRect(this.position.x * GRID_SIZE, this.position.y * GRID_SIZE, GRID_SIZE, GRID_SIZE); ctx.strokeStyle = BLACK; ctx.strokeRect(this.position.x * GRID_SIZE, this.position.y * GRID_SIZE, GRID_SIZE, GRID_SIZE); }
        }

        class Game {
            constructor(canvas) {
                this.canvas = canvas; this.ctx = canvas.getContext('2d');
                this.snakes = [ // Now 5 snakes
                    new SnakeO(0, { x: Math.floor(1 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }, RIGHT, SNAKE1_COLOR),
                    new SnakeO1(1, { x: Math.floor(2 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }, RIGHT, SNAKE2_COLOR),
                    new SnakeO2(2, { x: Math.floor(3 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }, LEFT, SNAKE3_COLOR),
                    new SnakeO3(3, { x: Math.floor(4 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }, LEFT, SNAKE4_COLOR),
                    new SnakeRL(4, { x: Math.floor(5 * GRID_WIDTH / 6), y: Math.floor(GRID_HEIGHT / 2) }, RIGHT, SNAKE_RL_COLOR) // The RL Snake
                ];
                this.foods = []; this.initialize_food();
                this.lastFrameTime = 0; this.fps = 0;
            }
            initialize_food() { for (let i = 0; i < TARGET_FOOD_COUNT; i++) this.spawn_food(); }
            spawn_food(position = null) { /* ... (same as before, ensure it checks all 5 snakes) ... */
                let food = new Food(position);
                const all_snake_positions = this.snakes.reduce((acc, snake) => {
                    if (snake.alive) return acc.concat(snake.positions); return acc;
                }, []);
                let is_colliding = true; let attempts = 0; const max_attempts = GRID_WIDTH * GRID_HEIGHT;
                while(is_colliding && attempts < max_attempts) {
                    is_colliding = false;
                    for(const sp of all_snake_positions) { if (sp.x === food.position.x && sp.y === food.position.y) { is_colliding = true; food.position = food.randomize_position(); break; } }
                    if (!is_colliding) { for(const other_food of this.foods) { if (other_food.position.x === food.position.x && other_food.position.y === food.position.y) { is_colliding = true; food.position = food.randomize_position(); break; } } }
                    attempts++;
                }
                if (attempts >= max_attempts && is_colliding) { console.warn("Could not find valid position for food."); return false; }
                this.foods.push(food); return true;
            }
            update() { /* ... (same as before, ensure loops cover all 5 snakes) ... */
                let food_to_spawn_from_deaths = [];
                for (let i = 0; i < this.snakes.length; i++) {
                    const snake = this.snakes[i];
                    const other_snakes_positions = this.snakes.reduce((acc, s, index) => {
                        if (index !== i && s.alive) return acc.concat(s.positions); return acc;
                    }, []);
                    const food_spawned_from_death = snake.update(other_snakes_positions); // update now sets last_collision_type
                    food_to_spawn_from_deaths = food_to_spawn_from_deaths.concat(food_spawned_from_death);
                }
                food_to_spawn_from_deaths.forEach(pos => this.spawn_food(pos));

                for (const snake of this.snakes) {
                    if (!snake.alive) continue;
                    const head = snake.get_head_position();
                    for (let i = this.foods.length - 1; i >= 0; i--) {
                        const food = this.foods[i];
                        if (head.x === food.position.x && head.y === food.position.y) {
                            snake.length++; snake.score++;
                            if (hasattr(snake, 'hunger')) snake.hunger = 0;
                            this.foods.splice(i, 1);
                        }
                    }
                }
                const foodNeeded = TARGET_FOOD_COUNT - this.foods.length;
                for (let i = 0; i < foodNeeded; i++) this.spawn_food();
            }
            move_ai() { /* ... (same as before, ensure loops cover all 5 snakes) ... */
                const food_positions = this.foods.map(f => f.position);
                const all_alive_heads = this.snakes.filter(s => s.alive).map(s => s.get_head_position());

                for (let i = 0; i < this.snakes.length; i++) {
                    const snake = this.snakes[i];
                    if (!snake.alive) continue;

                    const other_snakes_positions = this.snakes.reduce((acc, s, index) => {
                        if (index !== i && s.alive) return acc.concat(s.positions); return acc;
                    }, []);
                    const other_snakes_heads = all_alive_heads.filter(h => {
                        const current_snake_head = snake.get_head_position();
                        return !(h.x === current_snake_head.x && h.y === current_snake_head.y);
                    });
                    // SnakeRL's ai_move uses window.game.snakes and window.game.foods directly for state.
                    // Other snakes use the filtered lists.
                    snake.ai_move(food_positions, other_snakes_positions, other_snakes_heads);
                }
            }
            render_grid() { /* ... (same as before) ... */
                this.ctx.strokeStyle = GRID_COLOR; this.ctx.lineWidth = 1;
                for (let x = 0; x <= SCREEN_WIDTH; x += GRID_SIZE) { this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, SCREEN_HEIGHT); this.ctx.stroke(); }
                for (let y = 0; y <= SCREEN_HEIGHT; y += GRID_SIZE) { this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(SCREEN_WIDTH, y); this.ctx.stroke(); }
            }
            render_text(text, x, y, color = WHITE, size = 18, font = "Arial") { /* ... (same as before) ... */
                this.ctx.fillStyle = color; this.ctx.font = `${size}px ${font}`; this.ctx.fillText(text, x, y);
            }
            render(timestamp) { /* ... (Updated for 5 snakes) ... */
                this.ctx.fillStyle = BLACK; this.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                this.render_grid();
                this.foods.forEach(food => food.render(this.ctx));
                this.snakes.forEach(snake => snake.render(this.ctx));

                this.ctx.textAlign = "center"; this.render_text('5 AI Snake Competition (1 RL)', SCREEN_WIDTH / 2, 30, WHITE, 24); this.ctx.textAlign = "left";
                if (this.lastFrameTime > 0) { const deltaTime = timestamp - this.lastFrameTime; this.fps = Math.round(1000 / deltaTime); }
                this.lastFrameTime = timestamp; this.render_text(`FPS: ${this.fps}`, SCREEN_WIDTH - 100, 25, WHITE, 18);

                this.ctx.fillStyle = 'rgba(0,0,0,0.5)'; this.ctx.fillRect(5, 5, 150, 105); // Increased height for 5 scores
                const snake_names_render = ['O', 'O1', 'O2', 'O3', 'RL'];
                this.snakes.forEach((snake, i) => {
                    this.render_text(`${snake_names_render[i]}: ${snake.score}`, 10, 25 + i * 20, snake.color, 18);
                });

                this.ctx.fillStyle = 'rgba(0,0,0,0.5)'; this.ctx.fillRect(SCREEN_WIDTH - 305, SCREEN_HEIGHT - 95, 300, 90);
                const best_params_texts = [ /* ... (same) ... */
                    `O1 Best: S=${global_best_o1.score}, F=${global_best_o1.food_weight.toFixed(2)}, S=${global_best_o1.safety_weight.toFixed(2)}, L=${global_best_o1.look_ahead}, A=${global_best_o1.aggression.toFixed(2)}`,
                    `O2 Best: S=${global_best_o2.score}, F=${global_best_o2.food_weight.toFixed(2)}, S=${global_best_o2.safety_weight.toFixed(2)}, L=${global_best_o2.look_ahead}, A=${global_best_o2.aggression.toFixed(2)}`,
                    `O3 Best: S=${global_best_o3.score}, F=${global_best_o3.food_weight.toFixed(2)}, S=${global_best_o3.safety_weight.toFixed(2)}, L=${global_best_o3.look_ahead}, A=${global_best_o3.aggression.toFixed(2)}`
                ];
                best_params_texts.forEach((text, i) => { this.render_text(text, SCREEN_WIDTH - 300, SCREEN_HEIGHT - 85 + i * 18, WHITE, 14); });

                const current_params_texts = [ /* ... (same, exclude RL) ... */
                    `O1 Now: F=${this.snakes[1].food_weight.toFixed(2)}, S=${this.snakes[1].safety_weight.toFixed(2)}, L=${this.snakes[1].look_ahead}, A=${this.snakes[1].aggression.toFixed(2)}`,
                    `O2 Now: F=${this.snakes[2].food_weight.toFixed(2)}, S=${this.snakes[2].safety_weight.toFixed(2)}, L=${this.snakes[2].look_ahead}, A=${this.snakes[2].aggression.toFixed(2)}`,
                    `O3 Now: F=${this.snakes[3].food_weight.toFixed(2)}, S=${this.snakes[3].safety_weight.toFixed(2)}, L=${this.snakes[3].look_ahead}, A=${this.snakes[3].aggression.toFixed(2)}`
                ];
                current_params_texts.forEach((text, i) => { this.render_text(text, SCREEN_WIDTH - 300, SCREEN_HEIGHT - (85 - 3*18 - 5) + i * 18, WHITE, 14); }); // Adjusted y for spacing

                if (best_snake_overall.snake) { /* ... (same) ... */
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)'; this.ctx.fillRect(5, SCREEN_HEIGHT - 55, 450, 50);
                    const overall_text = `Best Overall: ${best_snake_overall.snake.replace('Snake', '')} (S=${best_snake_overall.score}, F=${best_snake_overall.food_weight.toFixed(2)}, S=${best_snake_overall.safety_weight.toFixed(2)}, L=${best_snake_overall.look_ahead}, A=${best_snake_overall.aggression.toFixed(2)})`;
                    this.render_text(overall_text, 10, SCREEN_HEIGHT - 35, WHITE, 14);
                }

                this.ctx.fillStyle = 'rgba(0,0,0,0.5)'; this.ctx.fillRect(SCREEN_WIDTH - 155, 45, 150, 200); // Increased height for 5 death messages
                this.snakes.forEach((snake, i) => {
                    if (!snake.alive) {
                        this.render_text(`${snake_names_render[i]} died!`, SCREEN_WIDTH - 150, 60 + i * 35, RED, 14);
                        const respawnTimeSec = Math.ceil(snake.respawn_counter / (1000 / gameSpeed));
                        this.render_text(`Respawn: ${respawnTimeSec}s`, SCREEN_WIDTH - 150, 78 + i * 35, WHITE, 14);
                    }
                });

                const snakeO3 = this.snakes[3]; // O3 is index 3
                if (snakeO3 && snakeO3.alive && hasattr(snakeO3, 'hunger')) { /* ... (same health bar for O3) ... */
                    this.render_text('AI O3 Health', SCREEN_WIDTH - 150, SCREEN_HEIGHT - 180, WHITE, 14); // Adjusted Y
                    const max_hunger = 1000; const health_percentage = Math.max(0, 1 - (snakeO3.hunger / max_hunger));
                    const health_bar_width = 100 * health_percentage;
                    this.ctx.fillStyle = RED; this.ctx.fillRect(SCREEN_WIDTH - 150, SCREEN_HEIGHT - 170, 100, 10);
                    this.ctx.fillStyle = 'rgb(0,255,0)'; this.ctx.fillRect(SCREEN_WIDTH - 150, SCREEN_HEIGHT - 170, health_bar_width, 10);
                    this.ctx.strokeStyle = WHITE; this.ctx.strokeRect(SCREEN_WIDTH - 150, SCREEN_HEIGHT - 170, 100, 10);
                }
            }
        }

        // --- Game Setup and Loop ---
        const canvas = document.getElementById('gameCanvas');
        canvas.width = SCREEN_WIDTH; canvas.height = SCREEN_HEIGHT;

        window.game = new Game(canvas); // Make game global for SnakeRL to access game.snakes
        let gameSpeed = 10; // Target FPS
        let lastTick = 0;

        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);
            const now = timestamp; const elapsed = now - lastTick;
            if (elapsed > (1000 / gameSpeed)) {
                lastTick = now - (elapsed % (1000 / gameSpeed));
                window.game.move_ai();
                window.game.update();
            }
            window.game.render(timestamp);
        }

        // --- UI for Parameters (Non-RL snakes) ---
        const infoButton = document.getElementById('infoButton');
        const paramsPanel = document.getElementById('paramsPanel');
        const applyParamsButton = document.getElementById('applyParamsButton');
        const closeParamsButton = document.getElementById('closeParamsButton');
        const snakeParamsFormsDiv = document.getElementById('snakeParamsForms');

        function populateParamsPanel() {
            snakeParamsFormsDiv.innerHTML = '';
            const learningSnakes = [window.game.snakes[1], window.game.snakes[2], window.game.snakes[3]]; // O1, O2, O3
            learningSnakes.forEach((snake) => {
                if (!snake || snake.name === "RL") return; // Skip RL snake for param panel
                const snakeDiv = document.createElement('div'); snakeDiv.className = 'snake-params';
                snakeDiv.innerHTML = `<h4>Snake ${snake.name} (Current)</h4>`;
                const params = ['food_weight', 'safety_weight', 'look_ahead', 'aggression'];
                params.forEach(param => {
                    const label = document.createElement('label'); label.textContent = `${param.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}:`;
                    const input = document.createElement('input'); input.type = 'number';
                    input.id = `snake${snake.snake_id}_${param}`;
                    input.value = snake[param].toFixed(param === 'look_ahead' ? 0 : 2);
                    input.step = (param === 'look_ahead') ? "1" : "0.01";
                    label.appendChild(input); snakeDiv.appendChild(label);
                });
                snakeParamsFormsDiv.appendChild(snakeDiv);
            });
        }
        infoButton.addEventListener('click', () => { /* ... (same) ... */
            if (paramsPanel.style.display === 'none' || paramsPanel.style.display === '') { populateParamsPanel(); paramsPanel.style.display = 'block'; }
            else { paramsPanel.style.display = 'none'; }
        });
        closeParamsButton.addEventListener('click', () => { paramsPanel.style.display = 'none'; });
        applyParamsButton.addEventListener('click', () => { /* ... (same, ensure it targets correct snakes) ... */
            const learningSnakesToUpdate = [window.game.snakes[1], window.game.snakes[2], window.game.snakes[3]];
            learningSnakesToUpdate.forEach((snake) => {
                if (!snake || snake.name === "RL") return;
                const paramsToUpdate = ['food_weight', 'safety_weight', 'look_ahead', 'aggression'];
                paramsToUpdate.forEach(param => {
                    const inputElement = document.getElementById(`snake${snake.snake_id}_${param}`);
                    if (inputElement) {
                        let value = parseFloat(inputElement.value);
                        if (param === 'look_ahead') value = parseInt(inputElement.value);
                        if (!isNaN(value)) {
                            if (param === 'food_weight' || param === 'safety_weight') value = Math.max(0.1, Math.min(5.0, value));
                            if (param === 'aggression') value = Math.max(0.0, Math.min(2.0, value));
                            if (param === 'look_ahead') value = Math.max(1, Math.min(10, value));
                            snake[param] = value; snake[`best_${param}`] = value;
                        }
                    }
                });
            });
            console.log("Non-RL Parameters applied manually.");
        });

        // Start the game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>